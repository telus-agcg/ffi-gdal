module GDAL
  module RasterBandMixins
    module AlgorithmMethods
      def self.included: (untyped base) -> untyped

      module ClassMethods
        # Compute the optimal PCT for RGB image. Implements a median cut
        # algorithm to compute an "optimal" pseudo-color table for representing
        # an input RGB image. This PCT could then be used with
        # +dither_rgb_to_pct+ to convert a 24-bit RGB image into an 8-bit
        # pseudo-colored image.
        #
        # @param red_band [GDAL::RasterBand, FFI::Pointer]
        # @param green_band [GDAL::RasterBand, FFI::Pointer]
        # @param blue_band [GDAL::RasterBand, FFI::Pointer]
        # @param colors [Integer] Number of colors to return; 2-256.
        # @param color_interpretation [FFI::GDAL::GDAL::PaletteInterp] The type
        #   of ColorTable to return.
        # @param progress_function [Proc, FFI:GDAL::GDAL.ProgressFunc]
        # @param progress_arg [FFI::Pointer] Usually used when when using a
        #   +FFI::CPL::Progress.GDALCreateScaledProgress+.
        # @return [GDAL::ColorTable]
        def compute_median_cut_pct: (untyped red_band, untyped green_band, untyped blue_band, untyped colors, untyped color_interpretation, ?progress_function: untyped? progress_function, ?progress_arg: untyped? progress_arg) -> untyped

        # 24-bit to 8-bit conversion with dithering.  Utilizes Floyd-Steinberg
        # dithering, using the provided color table.
        #
        # The red, green, and blue input bands do not necessarily need to come
        # from the same file, but they must be the same width and height. They
        # will be clipped to 8-bit during reading, so non-eight bit bands are
        # generally inappropriate. Likewise, +output_band+ will be written with
        # 8-bit values and must match the width and height of the source bands.
        #
        # The ColorTable cannot have more than 256 entries.
        #
        # @param red_band [GDAL::RasterBand, FFI::Pointer]
        # @param green_band [GDAL::RasterBand, FFI::Pointer]
        # @param blue_band [GDAL::RasterBand, FFI::Pointer]
        # @param output_band [GDAL::RasterBand, FFI::Pointer]
        # @param color_table [GDAL::ColorTable, FFI::Pointer]
        # @param progress_function [Proc, FFI:GDAL::GDAL.ProgressFunc]
        # @param progress_arg [FFI::Pointer] Usually used when when using a
        #   +FFI::CPL::Progress.GDALCreateScaledProgress+.
        # @return [GDAL::RasterBand] +output_band+ with the dithering algorithm
        #   applied.
        def dither_rgb_to_pct: (untyped red_band, untyped green_band, untyped blue_band, untyped output_band, untyped color_table, ?progress_function: untyped? progress_function, ?progress_arg: untyped? progress_arg) -> untyped
      end

      # Computes a 16-bit (0-65535) checksum from a region of raster data.
      # Floating point data is converted to 32-bit integers so decimal portions
      # of the raster data won't affect the checksum.  Real and imaginary
      # components of complex bands influence the result.
      #
      # @param x_offset [Integer]
      # @param y_offset [Integer]
      # @param x_size [Integer]
      # @param y_size [Integer]
      # @return [Integer] The checksum value.
      def checksum_image: (untyped x_offset, untyped y_offset, untyped x_size, untyped y_size) -> untyped

      # Computes the proximity of all pixels in the proximity_band to those in
      # this band. By default all non-zero pixels in this band will be
      # considered as "target", and all proximities will be computed in pixels.
      # Target pixels are set to the value corresponding to a distance of zero.
      #
      # Note that this modifies the source band in place with the computed
      # values.
      #
      # @param proximity_band [GDAL::RasterBand, FFI::Pointer]
      # @param progress_function [Proc, FFI:GDAL::GDAL.ProgressFunc]
      # @param progress_arg [FFI::Pointer] Usually used when when using a
      #   +FFI::CPL::Progress.GDALCreateScaledProgress+.
      # @param options [Hash]
      # @option options [String] values A list of target pixel values to measure
      #   the distance from. If this isn't provided, proximity will be computed
      #   from non-zero pixel values.
      # @option options [String] distunits (PIXEL) Indicates what unit type to
      #   use for computing.
      # @option options [Integer] maxdist The maximum distance to search.
      # @option options [Integer] nodata If not given, it will try to use the
      #   nodata value on the +proximity_band+. If not found there, will use
      #   65535.
      # @option options [Integer] fixed_buf_val If set, all pixels within the
      #   +maxdist+ threshold are set to this fixed value instead of to a
      #   proximity distance.
      def compute_proximity!: (untyped proximity_band, ?progress_function: untyped? progress_function, ?progress_arg: untyped? progress_arg, **untyped options) -> untyped

      # Fill selected raster regions by interpolation from the edges. It
      # interpolates values for all designated nodata pixels (marked by zeroes
      # in +mask_band+). For each pixel, a four-direction conic search is done
      # to find values to interpolate from (using inverse distance weighting).
      # Once all values are interpolated, zero or more smoothing iterations
      # (3x3 average filters on interpolated pixels) are applied to smooth out
      # artifacts.
      #
      # This is generally suitable for interpolating missing regions of fairly
      # continuously varying rasters (such as elevation models, for instance).
      # It is also suitable for filling small holes and cracks in more
      # irregularly varying images (like aerial photos). Its is generally not so
      # great for interpolating a raster from sparse point data. See GDAL::Grid
      # for that case.
      #
      # Note that this alters values of the current raster band.
      #
      # @param mask_band [GDAL::RasterBand] Band that indicates which pixels to
      #   be interpolated (it does so using 0-valued pixels).
      # @param max_search_distance [Float] Max number of pixels to search in all
      #   directions to find values to interpolate from.
      # @param smoothing_iterations [Integer] The number of 3x3 smoothing filter
      #   passes to run.  Can be 0.
      # @param progress_function [Proc, FFI:GDAL::GDAL.ProgressFunc]
      # @param progress_arg [FFI::Pointer] Usually used when when using a
      #   +FFI::CPL::Progress.GDALCreateScaledProgress+.
      # @param options [Hash]
      # TODO: document what valid options are.
      def fill_nodata!: (untyped mask_band, untyped max_search_distance, untyped smoothing_iterations, ?progress_function: untyped? progress_function, ?progress_arg: untyped? progress_arg, **untyped options) -> untyped

      # Creates vector polygons for all connected regions of pixels in the raster
      # that share a common pixel value. Optionally, each polygon may be
      # labeled with the pixel value in an attribute. Optionally, a mask band
      # can be provided to determine which pixels are eligible for processing.
      #
      # The C API implements two functions for this: +GDALPolygonize+ and
      # +GDALFPolygonize+, where the former uses a 32-bit Integer buffer and the
      # latter uses a 32-bit Float buffer. The Integer version may be quicker,
      # but the Float version more accurate. As such, calling +polygonize+
      # defaults to use the Float version internally, but you can tell it to use
      # the Integer version by using the +use_integer_function+ flag.
      #
      # Polygon features will be created on +layer+ with Polygon geometries
      # representing the polygons. The geometries will be in the georeferenced
      # coordinate system of the image (based on the GeoTransform) of the source
      # Dataset). It is acceptable for +layer+ to already have other features.
      #
      # Note that this does not set the coordinate system on the output
      # layer--the application is responsible for doing so.
      #
      # @param layer [OGR::Layer, FFI::Pointer] The layer to write the polygons
      #   to.
      # @param mask_band [GDAL::RasterBand, FFI::Pointer] Optional band, where all
      #   pixels in the mask with a value other than zero will be considered
      #   suitable for collection as polygons.
      # @param pixel_value_field [Integer] Index of the feature attribute into
      #   which the pixel value of the polygon should be written.
      # @param use_integer_function [Boolean] Indicates using GDAL's
      #   GDALPolygonize() instead of GDALFPolygonize(); the former uses a
      #   32-bit integer buffer for reading pixel band values, the latter uses a
      #   32-bit float buffer. The integer based function is faster but less
      #   precise.
      # @param options [Hash]
      # @option options [Integer] '8CONNECTED' (4) Set to 8 to use 8
      #   connectedness.
      # @param progress_function [Proc, FFI:GDAL::GDAL.ProgressFunc]
      # @param progress_arg [FFI::Pointer] Usually used when when using a
      #   +FFI::CPL::Progress.GDALCreateScaledProgress+.
      # @return [OGR::Layer]
      def polygonize: (untyped layer, ?mask_band: untyped? mask_band, ?pixel_value_field: ::Integer pixel_value_field, ?use_integer_function: bool use_integer_function, ?progress_function: untyped? progress_function, ?progress_arg: untyped? progress_arg, **untyped options) -> untyped

      # Removes raster polygons that are smaller than the given threshold (in
      # pixels) and replaces them with the pixel value of the largest neighbor
      # polygon. Polygons are determined as regions of the raster where the
      # pixels all have the same value, and that are contiguous (connected).
      #
      # If +mask_band+ is given, "nodata" pixels in the band will not be treated
      # as part of a polygon, regardless of their pixel values.
      #
      # @param size_threshold [Integer] Polygons found in the raster with sizes
      #   smaller than this will be merged into their largest neighbor.
      # @param connectedness [Integer] 4 or 8. 4 indicates that diagonal pixels
      #   are not considered directly adjacent for polygon membership purposes;
      #   8 indicates they are.
      # @param mask_band [GDAL::RasterBand] [description] All pixels in this
      #   band with a value other than 0 will be considered suitable for
      #   inclusion in polygons.
      # @param progress_function [Proc, FFI:GDAL::GDAL.ProgressFunc]
      # @param progress_arg [FFI::Pointer] Usually used when when using a
      #   +FFI::CPL::Progress.GDALCreateScaledProgress+.
      # @param options [Hash] None supported in GDAL as of this writing.
      def sieve_filter!: (untyped size_threshold, untyped connectedness, ?mask_band: untyped? mask_band, ?progress_function: untyped? progress_function, ?progress_arg: untyped? progress_arg, **untyped options) -> untyped

      # The same as +sieve_filter!+, but returns a new GDAL::RasterBand as the
      # result.
      #
      # @see +sieve_filter!
      # @param destination_band [GDAL::RasterBand]
      def sieve_filter: (untyped size_threshold, untyped connectedness, untyped destination_band, ?mask_band: untyped? mask_band, ?progress_function: untyped? progress_function, ?progress_arg: untyped? progress_arg, **untyped options) -> untyped

      private

      # @param size_threshold [Integer] Polygons found in the raster with sizes
      #   smaller than this will be merged into their largest neighbor.
      # @param connectedness [Integer] 4 or 8. 4 indicates that diagonal pixels
      #   are not considered directly adjacent for polygon membership purposes;
      #   8 indicates they are.
      # @param mask_band [GDAL::RasterBand] [description] All pixels in this
      #   band with a value other than 0 will be considered suitable for
      #   inclusion in polygons.
      # @param progress_function [Proc, FFI:GDAL::GDAL.ProgressFunc]
      # @param progress_arg [FFI::Pointer] Usually used when when using a
      #   +FFI::CPL::Progress.GDALCreateScaledProgress+.
      # @param options [Hash] None supported in GDAL as of this writing.
      def _sieve_filter: (untyped size_threshold, untyped connectedness, untyped destination_band, ?mask_band: untyped? mask_band, ?progress_function: untyped? progress_function, ?progress_arg: untyped? progress_arg, **untyped options) -> untyped
    end
  end
end
